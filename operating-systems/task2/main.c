/* Определить значения переменных a, b, c, d, a1, b1, c1, а также содержимое массивов buf и buf1
 * после выполнения  программы на языке программирования Си в UNIX–подобной операционной системе
 * при условии, что файла a.txt не существует в текущей директории.
 * Что изменится при повторном запуске программы? Обосновать свое решение. */

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main()
{
    setbuf(stdin, NULL);

    int a = 4, b = 4, c = 4, d = 4, a1 = 4, b1 = 4, c1 = 4;
    int p[2];
    char buf[50], buf1[50];
    memset(buf, 0, 50);     // заполняем buf нулями
    memset(buf1, 0, 50);    // заполняем buf1 нулями

    close(1);   // из таблицы дескрипторов открытых файлов
                // удаляется файл стандартного вывода tty1

    pipe(p);    // создаем pipe, p[0] = 1, p[1] = 3

    creat("a.txt", 600);    // при первом запуске:
                            // возвращенный дескриптор 4,
                            // права: 600 = 1 001 011 000 (2)
                            // владелец - исполнять
                            // группа - писать и исполнять
                            // остальные - ничего
    // при повторном запуске перезаписывания файла
    // не происходит из-за отсутствия необходимых прав

    close(0);   // из таблицы дескрипторов открытых файлов
                // удаляется файл стандартного ввода tty0

    dup(p[0]);  // по дескриптору 0 теперь можно читать из pipe-а
    if (fork() == 0)
    {
        // процесс-сын
        close(p[0]);            // закрываем дескриптор 1
        dup(p[1]);              // по дескриптору 1 теперь можно писать в pipe

        printf("time\n");       // в pipe написали строку "time\n", но сразу в
                                // pipe она не попала из-за буферизации

        c = write(a, "datа", 5);    // при первом запуске: пишем по дескриптору 4,
                                    // соответствующему файлу "a.txt", строку "data\0"
                                    // (с нуль-терминатором), c = 5
                                    // при повторном запуске: дескриптору 4 не
                                    // соответствует открытый файл, c = -1

        a = open("a.txt", 0);   // прав на чтение у владельца нет, a = -1
        b = read(a, buf, 2);    // попытка чтения через дескриптор -1, ошибка, b = -1
        d = write(1, "realy", 4);   // в pipe написали "real", d = 4
        exit(2);    // выходим, выталкивая буфер и возвращая статус 2;
                    // после выталкивания буфера в pipe-е находится "realtime\n"
    }
    else
    {
        // процесс-отец
        wait(&b1);          // b1 = 512
        /* В единственный аргумент wait записывается причина смерти сына.
         * Т.к. сын был завершен с помощью exit, то младшие 7 бит (0-6) содержат нули.
         * 7-й бит содержит 0: образ процесса был сохранен, процесс-сын завершен нормально.
         * Биты с 8 по 15 биты аргумент функции exit, т.е. 2 = 0000 0010.
         * Таким образом, b1 = 0000 0010 0000 0000 (2) = 512 (10) */
        close(p[1]);        // закрыли 3

        scanf("%s", buf);           // в buf считали "realtime" из pipe-а
        a1 = read(p[0], buf1, 6);   // pipe пуст, в buf1 ничего не считано, a1 = 0
        c1 = open("a.txt", 0);      // прав на чтение у владельца нет, c1 = -1
    }

    /* Итог.
     *
     * При первом запуске значения переменных в конце выполнения программы:
     * - В процессе-отце:
     *   a  = 4
     *   b  = 4
     *   c  = 4
     *   d  = 4
     *   a1 = 0
     *   b1 = 512
     *   c1 = -1
     *   p = {1, 3}
     *   buf  = "realtime\0\0...\0" (остаток буфера заполнен нулями)
     *   buf1 = "\0\0...\0" (весь буфер заполнен нулями)
     * - В процессе-сыне:
     *   a  = -1
     *   b  = -1
     *   c  = 5
     *   d  = 4
     *   a1 = 4
     *   b1 = 4
     *   c1 = 4
     *   p = {1, 3}
     *   buf  = "\0\0...\0" (весь буфер заполнен нулями)
     *   buf1 = "\0\0...\0" (весь буфер заполнен нулями)
     *
     * При повторном запуске значения переменных в конце выполнения программы:
     * - В процессе-отце:
     *   a  = 4
     *   b  = 4
     *   c  = 4
     *   d  = 4
     *   a1 = 0
     *   b1 = 512
     *   c1 = -1
     *   p = {1, 3}
     *   buf  = "realtime\0\0...\0" (остаток буфера заполнен нулями)
     *   buf1 = "\0\0...\0" (весь буфер заполнен нулями)
     * - В процессе-сыне:
     *   a  = -1
     *   b  = -1
     *   c  = -1
     *   d  = 4
     *   a1 = 4
     *   b1 = 4
     *   c1 = 4
     *   p = {1, 3}
     *   buf  = "\0\0...\0" (весь буфер заполнен нулями)
     *   buf1 = "\0\0...\0" (весь буфер заполнен нулями) */
}
